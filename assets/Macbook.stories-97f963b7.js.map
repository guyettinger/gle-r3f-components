{"version":3,"file":"Macbook.stories-97f963b7.js","sources":["../../node_modules/@react-three/drei/web/Html.js","../../node_modules/three-stdlib/_polyfill/constants.js","../../node_modules/three-stdlib/utils/BufferGeometryUtils.js","../../node_modules/fflate/esm/browser.js","../../node_modules/three-stdlib/objects/GroundProjectedEnv.js","../../node_modules/three-stdlib/controls/OrbitControls.js","../../node_modules/three-stdlib/_polyfill/LoaderUtils.js","../../node_modules/three-stdlib/loaders/GLTFLoader.js","../../node_modules/three-stdlib/shaders/HorizontalBlurShader.js","../../node_modules/three-stdlib/shaders/VerticalBlurShader.js","../../node_modules/three-stdlib/loaders/RGBELoader.js","../../node_modules/three-stdlib/loaders/EXRLoader.js","../../node_modules/three-stdlib/loaders/DRACOLoader.js","../../node_modules/three-stdlib/libs/MeshoptDecoder.js","../../node_modules/@react-three/drei/core/Gltf.js","../../node_modules/@react-three/drei/core/OrbitControls.js","../../node_modules/@react-three/drei/helpers/deprecated.js","../../node_modules/@monogrid/gainmap-js/dist/QuadRenderer-6HrRQdJM.js","../../node_modules/@monogrid/gainmap-js/dist/decode.js","../../node_modules/@react-three/drei/helpers/environment-assets.js","../../node_modules/@react-three/drei/core/useEnvironment.js","../../node_modules/@react-three/drei/core/Environment.js","../../node_modules/@react-three/drei/core/ContactShadows.js","../../src/components/Macbook/Macbook.tsx"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom/client';\nimport { Vector3, DoubleSide, OrthographicCamera, PerspectiveCamera, Vector2 } from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\n\nconst v1 = /* @__PURE__ */new Vector3();\nconst v2 = /* @__PURE__ */new Vector3();\nconst v3 = /* @__PURE__ */new Vector3();\nconst v4 = /* @__PURE__ */new Vector2();\nfunction defaultCalculatePosition(el, camera, size) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  objectPos.project(camera);\n  const widthHalf = size.width / 2;\n  const heightHalf = size.height / 2;\n  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];\n}\nfunction isObjectBehindCamera(el, camera) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n  const deltaCamObj = objectPos.sub(cameraPos);\n  const camDir = camera.getWorldDirection(v3);\n  return deltaCamObj.angleTo(camDir) > Math.PI / 2;\n}\nfunction isObjectVisible(el, camera, raycaster, occlude) {\n  const elPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const screenPos = elPos.clone();\n  screenPos.project(camera);\n  v4.set(screenPos.x, screenPos.y);\n  raycaster.setFromCamera(v4, camera);\n  const intersects = raycaster.intersectObjects(occlude, true);\n  if (intersects.length) {\n    const intersectionDistance = intersects[0].distance;\n    const pointDistance = elPos.distanceTo(raycaster.ray.origin);\n    return pointDistance < intersectionDistance;\n  }\n  return true;\n}\nfunction objectScale(el, camera) {\n  if (camera instanceof OrthographicCamera) {\n    return camera.zoom;\n  } else if (camera instanceof PerspectiveCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const vFOV = camera.fov * Math.PI / 180;\n    const dist = objectPos.distanceTo(cameraPos);\n    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;\n    return 1 / scaleFOV;\n  } else {\n    return 1;\n  }\n}\nfunction objectZIndex(el, camera, zIndexRange) {\n  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const dist = objectPos.distanceTo(cameraPos);\n    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);\n    const B = zIndexRange[1] - A * camera.far;\n    return Math.round(A * dist + B);\n  }\n  return undefined;\n}\nconst epsilon = value => Math.abs(value) < 1e-10 ? 0 : value;\nfunction getCSSMatrix(matrix, multipliers, prepend = '') {\n  let matrix3d = 'matrix3d(';\n  for (let i = 0; i !== 16; i++) {\n    matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? ',' : ')');\n  }\n  return prepend + matrix3d;\n}\nconst getCameraCSSMatrix = (multipliers => {\n  return matrix => getCSSMatrix(matrix, multipliers);\n})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);\nconst getObjectCSSMatrix = (scaleMultipliers => {\n  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), 'translate(-50%,-50%)');\n})(f => [1 / f, 1 / f, 1 / f, 1, -1 / f, -1 / f, -1 / f, -1, 1 / f, 1 / f, 1 / f, 1, 1, 1, 1, 1]);\nfunction isRefObject(ref) {\n  return ref && typeof ref === 'object' && 'current' in ref;\n}\nconst Html = /* @__PURE__ */React.forwardRef(({\n  children,\n  eps = 0.001,\n  style,\n  className,\n  prepend,\n  center,\n  fullscreen,\n  portal,\n  distanceFactor,\n  sprite = false,\n  transform = false,\n  occlude,\n  onOcclude,\n  castShadow,\n  receiveShadow,\n  material,\n  geometry,\n  zIndexRange = [16777271, 0],\n  calculatePosition = defaultCalculatePosition,\n  as = 'div',\n  wrapperClass,\n  pointerEvents = 'auto',\n  ...props\n}, ref) => {\n  const {\n    gl,\n    camera,\n    scene,\n    size,\n    raycaster,\n    events,\n    viewport\n  } = useThree();\n  const [el] = React.useState(() => document.createElement(as));\n  const root = React.useRef();\n  const group = React.useRef(null);\n  const oldZoom = React.useRef(0);\n  const oldPosition = React.useRef([0, 0]);\n  const transformOuterRef = React.useRef(null);\n  const transformInnerRef = React.useRef(null);\n  // Append to the connected element, which makes HTML work with views\n  const target = (portal == null ? void 0 : portal.current) || events.connected || gl.domElement.parentNode;\n  const occlusionMeshRef = React.useRef(null);\n  const isMeshSizeSet = React.useRef(false);\n  const isRayCastOcclusion = React.useMemo(() => {\n    return occlude && occlude !== 'blending' || Array.isArray(occlude) && occlude.length && isRefObject(occlude[0]);\n  }, [occlude]);\n  React.useLayoutEffect(() => {\n    const el = gl.domElement;\n    if (occlude && occlude === 'blending') {\n      el.style.zIndex = `${Math.floor(zIndexRange[0] / 2)}`;\n      el.style.position = 'absolute';\n      el.style.pointerEvents = 'none';\n    } else {\n      el.style.zIndex = null;\n      el.style.position = null;\n      el.style.pointerEvents = null;\n    }\n  }, [occlude]);\n  React.useLayoutEffect(() => {\n    if (group.current) {\n      const currentRoot = root.current = ReactDOM.createRoot(el);\n      scene.updateMatrixWorld();\n      if (transform) {\n        el.style.cssText = `position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;`;\n      } else {\n        const vec = calculatePosition(group.current, camera, size);\n        el.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${vec[0]}px,${vec[1]}px,0);transform-origin:0 0;`;\n      }\n      if (target) {\n        if (prepend) target.prepend(el);else target.appendChild(el);\n      }\n      return () => {\n        if (target) target.removeChild(el);\n        currentRoot.unmount();\n      };\n    }\n  }, [target, transform]);\n  React.useLayoutEffect(() => {\n    if (wrapperClass) el.className = wrapperClass;\n  }, [wrapperClass]);\n  const styles = React.useMemo(() => {\n    if (transform) {\n      return {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: size.width,\n        height: size.height,\n        transformStyle: 'preserve-3d',\n        pointerEvents: 'none'\n      };\n    } else {\n      return {\n        position: 'absolute',\n        transform: center ? 'translate3d(-50%,-50%,0)' : 'none',\n        ...(fullscreen && {\n          top: -size.height / 2,\n          left: -size.width / 2,\n          width: size.width,\n          height: size.height\n        }),\n        ...style\n      };\n    }\n  }, [style, center, fullscreen, size, transform]);\n  const transformInnerStyles = React.useMemo(() => ({\n    position: 'absolute',\n    pointerEvents\n  }), [pointerEvents]);\n  React.useLayoutEffect(() => {\n    isMeshSizeSet.current = false;\n    if (transform) {\n      var _root$current;\n      (_root$current = root.current) == null || _root$current.render( /*#__PURE__*/React.createElement(\"div\", {\n        ref: transformOuterRef,\n        style: styles\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        ref: transformInnerRef,\n        style: transformInnerStyles\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        ref: ref,\n        className: className,\n        style: style,\n        children: children\n      }))));\n    } else {\n      var _root$current2;\n      (_root$current2 = root.current) == null || _root$current2.render( /*#__PURE__*/React.createElement(\"div\", {\n        ref: ref,\n        style: styles,\n        className: className,\n        children: children\n      }));\n    }\n  });\n  const visible = React.useRef(true);\n  useFrame(gl => {\n    if (group.current) {\n      camera.updateMatrixWorld();\n      group.current.updateWorldMatrix(true, false);\n      const vec = transform ? oldPosition.current : calculatePosition(group.current, camera, size);\n      if (transform || Math.abs(oldZoom.current - camera.zoom) > eps || Math.abs(oldPosition.current[0] - vec[0]) > eps || Math.abs(oldPosition.current[1] - vec[1]) > eps) {\n        const isBehindCamera = isObjectBehindCamera(group.current, camera);\n        let raytraceTarget = false;\n        if (isRayCastOcclusion) {\n          if (Array.isArray(occlude)) {\n            raytraceTarget = occlude.map(item => item.current);\n          } else if (occlude !== 'blending') {\n            raytraceTarget = [scene];\n          }\n        }\n        const previouslyVisible = visible.current;\n        if (raytraceTarget) {\n          const isvisible = isObjectVisible(group.current, camera, raycaster, raytraceTarget);\n          visible.current = isvisible && !isBehindCamera;\n        } else {\n          visible.current = !isBehindCamera;\n        }\n        if (previouslyVisible !== visible.current) {\n          if (onOcclude) onOcclude(!visible.current);else el.style.display = visible.current ? 'block' : 'none';\n        }\n        const halfRange = Math.floor(zIndexRange[0] / 2);\n        const zRange = occlude ? isRayCastOcclusion //\n        ? [zIndexRange[0], halfRange] : [halfRange - 1, 0] : zIndexRange;\n        el.style.zIndex = `${objectZIndex(group.current, camera, zRange)}`;\n        if (transform) {\n          const [widthHalf, heightHalf] = [size.width / 2, size.height / 2];\n          const fov = camera.projectionMatrix.elements[5] * heightHalf;\n          const {\n            isOrthographicCamera,\n            top,\n            left,\n            bottom,\n            right\n          } = camera;\n          const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);\n          const cameraTransform = isOrthographicCamera ? `scale(${fov})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;\n          let matrix = group.current.matrixWorld;\n          if (sprite) {\n            matrix = camera.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(group.current.scale);\n            matrix.elements[3] = matrix.elements[7] = matrix.elements[11] = 0;\n            matrix.elements[15] = 1;\n          }\n          el.style.width = size.width + 'px';\n          el.style.height = size.height + 'px';\n          el.style.perspective = isOrthographicCamera ? '' : `${fov}px`;\n          if (transformOuterRef.current && transformInnerRef.current) {\n            transformOuterRef.current.style.transform = `${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`;\n            transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400));\n          }\n        } else {\n          const scale = distanceFactor === undefined ? 1 : objectScale(group.current, camera) * distanceFactor;\n          el.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`;\n        }\n        oldPosition.current = vec;\n        oldZoom.current = camera.zoom;\n      }\n    }\n    if (!isRayCastOcclusion && occlusionMeshRef.current && !isMeshSizeSet.current) {\n      if (transform) {\n        if (transformOuterRef.current) {\n          const el = transformOuterRef.current.children[0];\n          if (el != null && el.clientWidth && el != null && el.clientHeight) {\n            const {\n              isOrthographicCamera\n            } = camera;\n            if (isOrthographicCamera || geometry) {\n              if (props.scale) {\n                if (!Array.isArray(props.scale)) {\n                  occlusionMeshRef.current.scale.setScalar(1 / props.scale);\n                } else if (props.scale instanceof Vector3) {\n                  occlusionMeshRef.current.scale.copy(props.scale.clone().divideScalar(1));\n                } else {\n                  occlusionMeshRef.current.scale.set(1 / props.scale[0], 1 / props.scale[1], 1 / props.scale[2]);\n                }\n              }\n            } else {\n              const ratio = (distanceFactor || 10) / 400;\n              const w = el.clientWidth * ratio;\n              const h = el.clientHeight * ratio;\n              occlusionMeshRef.current.scale.set(w, h, 1);\n            }\n            isMeshSizeSet.current = true;\n          }\n        }\n      } else {\n        const ele = el.children[0];\n        if (ele != null && ele.clientWidth && ele != null && ele.clientHeight) {\n          const ratio = 1 / viewport.factor;\n          const w = ele.clientWidth * ratio;\n          const h = ele.clientHeight * ratio;\n          occlusionMeshRef.current.scale.set(w, h, 1);\n          isMeshSizeSet.current = true;\n        }\n        occlusionMeshRef.current.lookAt(gl.camera.position);\n      }\n    }\n  });\n  const shaders = React.useMemo(() => ({\n    vertexShader: !transform ? /* glsl */`\n          /*\n            This shader is from the THREE's SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if \"transfrom\"\n            is false.\n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n\n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ` : undefined,\n    fragmentShader: /* glsl */`\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `\n  }), [transform]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: group\n  }), occlude && !isRayCastOcclusion && /*#__PURE__*/React.createElement(\"mesh\", {\n    castShadow: castShadow,\n    receiveShadow: receiveShadow,\n    ref: occlusionMeshRef\n  }, geometry || /*#__PURE__*/React.createElement(\"planeGeometry\", null), material || /*#__PURE__*/React.createElement(\"shaderMaterial\", {\n    side: DoubleSide,\n    vertexShader: shaders.vertexShader,\n    fragmentShader: shaders.fragmentShader\n  })));\n});\n\nexport { Html };\n","import { REVISION } from \"three\";\nconst version = parseInt(REVISION.replace(/\\D+/g, \"\"));\nexport {\n  version\n};\n//# sourceMappingURL=constants.js.map\n","import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n//# sourceMappingURL=BufferGeometryUtils.js.map\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' }))));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","import { Mesh, REVISION, IcosahedronGeometry, ShaderMaterial, DoubleSide } from \"three\";\nconst isCubeTexture = (def) => def && def.isCubeTexture;\nclass GroundProjectedEnv extends Mesh {\n  constructor(texture, options) {\n    var _a, _b;\n    const isCubeMap = isCubeTexture(texture);\n    const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    const defines = [\n      isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n      `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n    ];\n    const vertexShader = (\n      /* glsl */\n      `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    );\n    const fragmentShader = defines.join(\"\\n\") + /* glsl */\n    `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n    const uniforms = {\n      map: { value: texture },\n      height: { value: (options == null ? void 0 : options.height) || 15 },\n      radius: { value: (options == null ? void 0 : options.radius) || 100 }\n    };\n    const geometry = new IcosahedronGeometry(1, 16);\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide\n    });\n    super(geometry, material);\n  }\n  set radius(radius) {\n    this.material.uniforms.radius.value = radius;\n  }\n  get radius() {\n    return this.material.uniforms.radius.value;\n  }\n  set height(height) {\n    this.material.uniforms.height.value = height;\n  }\n  get height() {\n    return this.material.uniforms.height.value;\n  }\n}\nexport {\n  GroundProjectedEnv\n};\n//# sourceMappingURL=GroundProjectedEnv.js.map\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Ray, Plane, EventDispatcher, Vector3, MOUSE, TOUCH, Quaternion, PerspectiveCamera, OrthographicCamera, Spherical, Vector2 } from \"three\";\nconst _ray = new Ray();\nconst _plane = new Plane();\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180));\nconst moduloWrapAround = (offset, capacity) => (offset % capacity + capacity) % capacity;\nclass OrbitControls extends EventDispatcher {\n  constructor(object, domElement) {\n    super();\n    __publicField(this, \"object\");\n    __publicField(this, \"domElement\");\n    // Set to false to disable this control\n    __publicField(this, \"enabled\", true);\n    // \"target\" sets the location of focus, where the object orbits around\n    __publicField(this, \"target\", new Vector3());\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    __publicField(this, \"minDistance\", 0);\n    __publicField(this, \"maxDistance\", Infinity);\n    // How far you can zoom in and out ( OrthographicCamera only )\n    __publicField(this, \"minZoom\", 0);\n    __publicField(this, \"maxZoom\", Infinity);\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    __publicField(this, \"minPolarAngle\", 0);\n    // radians\n    __publicField(this, \"maxPolarAngle\", Math.PI);\n    // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n    __publicField(this, \"minAzimuthAngle\", -Infinity);\n    // radians\n    __publicField(this, \"maxAzimuthAngle\", Infinity);\n    // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"enableDamping\", false);\n    __publicField(this, \"dampingFactor\", 0.05);\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    __publicField(this, \"enableZoom\", true);\n    __publicField(this, \"zoomSpeed\", 1);\n    // Set to false to disable rotating\n    __publicField(this, \"enableRotate\", true);\n    __publicField(this, \"rotateSpeed\", 1);\n    // Set to false to disable panning\n    __publicField(this, \"enablePan\", true);\n    __publicField(this, \"panSpeed\", 1);\n    __publicField(this, \"screenSpacePanning\", true);\n    // if false, pan orthogonal to world-space direction camera.up\n    __publicField(this, \"keyPanSpeed\", 7);\n    // pixels moved per arrow key push\n    __publicField(this, \"zoomToCursor\", false);\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"autoRotate\", false);\n    __publicField(this, \"autoRotateSpeed\", 2);\n    // 30 seconds per orbit when fps is 60\n    __publicField(this, \"reverseOrbit\", false);\n    // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n    __publicField(this, \"reverseHorizontalOrbit\", false);\n    // true if you want to reverse the horizontal orbit direction\n    __publicField(this, \"reverseVerticalOrbit\", false);\n    // true if you want to reverse the vertical orbit direction\n    // The four arrow keys\n    __publicField(this, \"keys\", { LEFT: \"ArrowLeft\", UP: \"ArrowUp\", RIGHT: \"ArrowRight\", BOTTOM: \"ArrowDown\" });\n    // Mouse buttons\n    __publicField(this, \"mouseButtons\", {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN\n    });\n    // Touch fingers\n    __publicField(this, \"touches\", { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN });\n    __publicField(this, \"target0\");\n    __publicField(this, \"position0\");\n    __publicField(this, \"zoom0\");\n    // the target DOM element for key events\n    __publicField(this, \"_domElementKeyEvents\", null);\n    __publicField(this, \"getPolarAngle\");\n    __publicField(this, \"getAzimuthalAngle\");\n    __publicField(this, \"setPolarAngle\");\n    __publicField(this, \"setAzimuthalAngle\");\n    __publicField(this, \"getDistance\");\n    __publicField(this, \"listenToKeyEvents\");\n    __publicField(this, \"stopListenToKeyEvents\");\n    __publicField(this, \"saveState\");\n    __publicField(this, \"reset\");\n    __publicField(this, \"update\");\n    __publicField(this, \"connect\");\n    __publicField(this, \"dispose\");\n    this.object = object;\n    this.domElement = domElement;\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n    this.getPolarAngle = () => spherical.phi;\n    this.getAzimuthalAngle = () => spherical.theta;\n    this.setPolarAngle = (value) => {\n      let phi = moduloWrapAround(value, 2 * Math.PI);\n      let currentPhi = spherical.phi;\n      if (currentPhi < 0)\n        currentPhi += 2 * Math.PI;\n      if (phi < 0)\n        phi += 2 * Math.PI;\n      let phiDist = Math.abs(phi - currentPhi);\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI;\n        } else {\n          currentPhi += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi;\n      scope.update();\n    };\n    this.setAzimuthalAngle = (value) => {\n      let theta = moduloWrapAround(value, 2 * Math.PI);\n      let currentTheta = spherical.theta;\n      if (currentTheta < 0)\n        currentTheta += 2 * Math.PI;\n      if (theta < 0)\n        theta += 2 * Math.PI;\n      let thetaDist = Math.abs(theta - currentTheta);\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI;\n        } else {\n          currentTheta += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta;\n      scope.update();\n    };\n    this.getDistance = () => scope.object.position.distanceTo(scope.target);\n    this.listenToKeyEvents = (domElement2) => {\n      domElement2.addEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = domElement2;\n    };\n    this.stopListenToKeyEvents = () => {\n      this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = null;\n    };\n    this.saveState = () => {\n      scope.target0.copy(scope.target);\n      scope.position0.copy(scope.object.position);\n      scope.zoom0 = scope.object.zoom;\n    };\n    this.reset = () => {\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.zoom = scope.zoom0;\n      scope.object.updateProjectionMatrix();\n      scope.dispatchEvent(changeEvent);\n      scope.update();\n      state = STATE.NONE;\n    };\n    this.update = (() => {\n      const offset = new Vector3();\n      const up = new Vector3(0, 1, 0);\n      const quat = new Quaternion().setFromUnitVectors(object.up, up);\n      const quatInverse = quat.clone().invert();\n      const lastPosition = new Vector3();\n      const lastQuaternion = new Quaternion();\n      const twoPI = 2 * Math.PI;\n      return function update() {\n        const position = scope.object.position;\n        quat.setFromUnitVectors(object.up, up);\n        quatInverse.copy(quat).invert();\n        offset.copy(position).sub(scope.target);\n        offset.applyQuaternion(quat);\n        spherical.setFromVector3(offset);\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle());\n        }\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n        } else {\n          spherical.theta += sphericalDelta.theta;\n          spherical.phi += sphericalDelta.phi;\n        }\n        let min = scope.minAzimuthAngle;\n        let max = scope.maxAzimuthAngle;\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI)\n            min += twoPI;\n          else if (min > Math.PI)\n            min -= twoPI;\n          if (max < -Math.PI)\n            max += twoPI;\n          else if (max > Math.PI)\n            max -= twoPI;\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n          } else {\n            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n          }\n        }\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n        spherical.makeSafe();\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor);\n        } else {\n          scope.target.add(panOffset);\n        }\n        if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius);\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale);\n        }\n        offset.setFromSpherical(spherical);\n        offset.applyQuaternion(quatInverse);\n        position.copy(scope.target).add(offset);\n        if (!scope.object.matrixAutoUpdate)\n          scope.object.updateMatrix();\n        scope.object.lookAt(scope.target);\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor;\n          sphericalDelta.phi *= 1 - scope.dampingFactor;\n          panOffset.multiplyScalar(1 - scope.dampingFactor);\n        } else {\n          sphericalDelta.set(0, 0, 0);\n          panOffset.set(0, 0, 0);\n        }\n        let zoomChanged = false;\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null;\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            const prevRadius = offset.length();\n            newRadius = clampDistance(prevRadius * scale);\n            const radiusDelta = prevRadius - newRadius;\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n            scope.object.updateMatrixWorld();\n          } else if (scope.object.isOrthographicCamera) {\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0);\n            mouseBefore.unproject(scope.object);\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n            zoomChanged = true;\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0);\n            mouseAfter.unproject(scope.object);\n            scope.object.position.sub(mouseAfter).add(mouseBefore);\n            scope.object.updateMatrixWorld();\n            newRadius = offset.length();\n          } else {\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n            scope.zoomToCursor = false;\n          }\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n            } else {\n              _ray.origin.copy(scope.object.position);\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target);\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                _ray.intersectPlane(_plane, scope.target);\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1;\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n          }\n        }\n        scale = 1;\n        performCursorZoom = false;\n        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n          scope.dispatchEvent(changeEvent);\n          lastPosition.copy(scope.object.position);\n          lastQuaternion.copy(scope.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n        return false;\n      };\n    })();\n    this.connect = (domElement2) => {\n      if (domElement2 === document) {\n        console.error(\n          'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.'\n        );\n      }\n      scope.domElement = domElement2;\n      scope.domElement.style.touchAction = \"none\";\n      scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n      scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n      scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n      scope.domElement.addEventListener(\"wheel\", onMouseWheel);\n    };\n    this.dispose = () => {\n      var _a, _b, _c, _d, _e, _f;\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = \"auto\";\n      }\n      (_a = scope.domElement) == null ? void 0 : _a.removeEventListener(\"contextmenu\", onContextMenu);\n      (_b = scope.domElement) == null ? void 0 : _b.removeEventListener(\"pointerdown\", onPointerDown);\n      (_c = scope.domElement) == null ? void 0 : _c.removeEventListener(\"pointercancel\", onPointerUp);\n      (_d = scope.domElement) == null ? void 0 : _d.removeEventListener(\"wheel\", onMouseWheel);\n      (_e = scope.domElement) == null ? void 0 : _e.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n      (_f = scope.domElement) == null ? void 0 : _f.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      }\n    };\n    const scope = this;\n    const changeEvent = { type: \"change\" };\n    const startEvent = { type: \"start\" };\n    const endEvent = { type: \"end\" };\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6\n    };\n    let state = STATE.NONE;\n    const EPS = 1e-6;\n    const spherical = new Spherical();\n    const sphericalDelta = new Spherical();\n    let scale = 1;\n    const panOffset = new Vector3();\n    const rotateStart = new Vector2();\n    const rotateEnd = new Vector2();\n    const rotateDelta = new Vector2();\n    const panStart = new Vector2();\n    const panEnd = new Vector2();\n    const panDelta = new Vector2();\n    const dollyStart = new Vector2();\n    const dollyEnd = new Vector2();\n    const dollyDelta = new Vector2();\n    const dollyDirection = new Vector3();\n    const mouse = new Vector2();\n    let performCursorZoom = false;\n    const pointers = [];\n    const pointerPositions = {};\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n    function rotateLeft(angle) {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle;\n      } else {\n        sphericalDelta.theta -= angle;\n      }\n    }\n    function rotateUp(angle) {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle;\n      } else {\n        sphericalDelta.phi -= angle;\n      }\n    }\n    const panLeft = (() => {\n      const v = new Vector3();\n      return function panLeft2(distance, objectMatrix) {\n        v.setFromMatrixColumn(objectMatrix, 0);\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    })();\n    const panUp = (() => {\n      const v = new Vector3();\n      return function panUp2(distance, objectMatrix) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1);\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0);\n          v.crossVectors(scope.object.up, v);\n        }\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    })();\n    const pan = (() => {\n      const offset = new Vector3();\n      return function pan2(deltaX, deltaY) {\n        const element = scope.domElement;\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          const position = scope.object.position;\n          offset.copy(position).sub(scope.target);\n          let targetDistance = offset.length();\n          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);\n          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          panLeft(\n            deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix\n          );\n          panUp(\n            deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix\n          );\n        } else {\n          console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n          scope.enablePan = false;\n        }\n      };\n    })();\n    function dollyOut(dollyScale) {\n      if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n        scale /= dollyScale;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    }\n    function dollyIn(dollyScale) {\n      if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n        scale *= dollyScale;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    }\n    function updateMouseParameters(event) {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return;\n      }\n      performCursorZoom = true;\n      const rect = scope.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const w = rect.width;\n      const h = rect.height;\n      mouse.x = x / w * 2 - 1;\n      mouse.y = -(y / h) * 2 + 1;\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n    }\n    function clampDistance(dist) {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n    }\n    function handleMouseDownRotate(event) {\n      rotateStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownDolly(event) {\n      updateMouseParameters(event);\n      dollyStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownPan(event) {\n      panStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseMoveRotate(event) {\n      rotateEnd.set(event.clientX, event.clientY);\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n      scope.update();\n    }\n    function handleMouseMoveDolly(event) {\n      dollyEnd.set(event.clientX, event.clientY);\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale());\n      }\n      dollyStart.copy(dollyEnd);\n      scope.update();\n    }\n    function handleMouseMovePan(event) {\n      panEnd.set(event.clientX, event.clientY);\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n      scope.update();\n    }\n    function handleMouseWheel(event) {\n      updateMouseParameters(event);\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale());\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale());\n      }\n      scope.update();\n    }\n    function handleKeyDown(event) {\n      let needsUpdate = false;\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n      }\n      if (needsUpdate) {\n        event.preventDefault();\n        scope.update();\n      }\n    }\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        rotateStart.set(x, y);\n      }\n    }\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        panStart.set(x, y);\n      }\n    }\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX;\n      const dy = pointers[0].pageY - pointers[1].pageY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enablePan)\n        handleTouchStartPan();\n    }\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enableRotate)\n        handleTouchStartRotate();\n    }\n    function handleTouchMoveRotate(event) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        rotateEnd.set(x, y);\n      }\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n    }\n    function handleTouchMovePan(event) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        panEnd.set(x, y);\n      }\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n    }\n    function handleTouchMoveDolly(event) {\n      const position = getSecondPointerPosition(event);\n      const dx = event.pageX - position.x;\n      const dy = event.pageY - position.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyEnd.set(0, distance);\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n      dollyOut(dollyDelta.y);\n      dollyStart.copy(dollyEnd);\n    }\n    function handleTouchMoveDollyPan(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enablePan)\n        handleTouchMovePan(event);\n    }\n    function handleTouchMoveDollyRotate(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enableRotate)\n        handleTouchMoveRotate(event);\n    }\n    function onPointerDown(event) {\n      var _a, _b;\n      if (scope.enabled === false)\n        return;\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.ownerDocument.addEventListener(\"pointermove\", onPointerMove);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.addEventListener(\"pointerup\", onPointerUp);\n      }\n      addPointer(event);\n      if (event.pointerType === \"touch\") {\n        onTouchStart(event);\n      } else {\n        onMouseDown(event);\n      }\n    }\n    function onPointerMove(event) {\n      if (scope.enabled === false)\n        return;\n      if (event.pointerType === \"touch\") {\n        onTouchMove(event);\n      } else {\n        onMouseMove(event);\n      }\n    }\n    function onPointerUp(event) {\n      var _a, _b, _c;\n      removePointer(event);\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.releasePointerCapture(event.pointerId);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n        (_c = scope.domElement) == null ? void 0 : _c.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      }\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n    function onMouseDown(event) {\n      let mouseAction;\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT;\n          break;\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE;\n          break;\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT;\n          break;\n        default:\n          mouseAction = -1;\n      }\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseDownDolly(event);\n          state = STATE.DOLLY;\n          break;\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          } else {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          }\n          break;\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          } else {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onMouseMove(event) {\n      if (scope.enabled === false)\n        return;\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleMouseMoveRotate(event);\n          break;\n        case STATE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseMoveDolly(event);\n          break;\n        case STATE.PAN:\n          if (scope.enablePan === false)\n            return;\n          handleMouseMovePan(event);\n          break;\n      }\n    }\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) {\n        return;\n      }\n      event.preventDefault();\n      scope.dispatchEvent(startEvent);\n      handleMouseWheel(event);\n      scope.dispatchEvent(endEvent);\n    }\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enablePan === false)\n        return;\n      handleKeyDown(event);\n    }\n    function onTouchStart(event) {\n      trackPointer(event);\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false)\n                return;\n              handleTouchStartRotate();\n              state = STATE.TOUCH_ROTATE;\n              break;\n            case TOUCH.PAN:\n              if (scope.enablePan === false)\n                return;\n              handleTouchStartPan();\n              state = STATE.TOUCH_PAN;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false)\n                return;\n              handleTouchStartDollyPan();\n              state = STATE.TOUCH_DOLLY_PAN;\n              break;\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false)\n                return;\n              handleTouchStartDollyRotate();\n              state = STATE.TOUCH_DOLLY_ROTATE;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onTouchMove(event) {\n      trackPointer(event);\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleTouchMoveRotate(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false)\n            return;\n          handleTouchMovePan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false)\n            return;\n          handleTouchMoveDollyPan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false)\n            return;\n          handleTouchMoveDollyRotate(event);\n          scope.update();\n          break;\n        default:\n          state = STATE.NONE;\n      }\n    }\n    function onContextMenu(event) {\n      if (scope.enabled === false)\n        return;\n      event.preventDefault();\n    }\n    function addPointer(event) {\n      pointers.push(event);\n    }\n    function removePointer(event) {\n      delete pointerPositions[event.pointerId];\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    }\n    function trackPointer(event) {\n      let position = pointerPositions[event.pointerId];\n      if (position === void 0) {\n        position = new Vector2();\n        pointerPositions[event.pointerId] = position;\n      }\n      position.set(event.pageX, event.pageY);\n    }\n    function getSecondPointerPosition(event) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n      return pointerPositions[pointer.pointerId];\n    }\n    if (domElement !== void 0)\n      this.connect(domElement);\n    this.update();\n  }\n}\nclass MapControls extends OrbitControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n    this.screenSpacePanning = false;\n    this.mouseButtons.LEFT = MOUSE.PAN;\n    this.mouseButtons.RIGHT = MOUSE.ROTATE;\n    this.touches.ONE = TOUCH.PAN;\n    this.touches.TWO = TOUCH.DOLLY_ROTATE;\n  }\n}\nexport {\n  MapControls,\n  OrbitControls\n};\n//# sourceMappingURL=OrbitControls.js.map\n","function decodeText(array) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(array);\n  }\n  let s = \"\";\n  for (let i = 0, il = array.length; i < il; i++) {\n    s += String.fromCharCode(array[i]);\n  }\n  try {\n    return decodeURIComponent(escape(s));\n  } catch (e) {\n    return s;\n  }\n}\nexport {\n  decodeText\n};\n//# sourceMappingURL=LoaderUtils.js.map\n","import { Loader, LoaderUtils, FileLoader, Color, SpotLight, PointLight, DirectionalLight, MeshBasicMaterial, MeshPhysicalMaterial, Vector2, Matrix4, Vector3, Quaternion, InstancedMesh, InstancedBufferAttribute, Object3D, TextureLoader, ImageBitmapLoader, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, LinearFilter, LinearMipmapLinearFilter, RepeatWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, PropertyBinding, BufferGeometry, SkinnedMesh, Mesh, TriangleStripDrawMode, TriangleFanDrawMode, LineSegments, Line, LineLoop, Points, Group, PerspectiveCamera, MathUtils, OrthographicCamera, Skeleton, AnimationClip, Bone, InterpolateLinear, NearestFilter, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, ClampToEdgeWrapping, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, Texture, VectorKeyframeTrack, NumberKeyframeTrack, QuaternionKeyframeTrack, Box3, Sphere, Interpolant } from \"three\";\nimport { toTrianglesDrawMode } from \"../utils/BufferGeometryUtils.js\";\nimport { version } from \"../_polyfill/constants.js\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsDispersionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsBumpExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      const relativeUrl = LoaderUtils.extractUrlBase(url);\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function(gltf) {\n              onLoad(gltf);\n              scope.manager.itemEnd(url);\n            },\n            _onError\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError\n    );\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      if (!plugin.name)\n        console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(16777215);\n    if (lightDef.color !== void 0)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\")\n      return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      const colorFactor = extension.sheenColorFactor;\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace\n    );\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n    if (extension.bumpTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter\n            );\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor;\n          return attributes[key];\n        })\n      );\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new Matrix4();\n        const p = new Vector3();\n        const q = new Quaternion();\n        const s = new Vector3(1, 1, 1);\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName === \"_COLOR_0\") {\n            const attr = attributes[attributeName];\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n          } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function(geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== void 0)\n                attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject\n        );\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = new Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = new Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(\n      this._invokeAll(function(ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      return Promise.all(\n        parser._invokeAll(function(ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })\n      ).then(function() {\n        for (const scene of result.scenes) {\n          scene.updateMatrixWorld();\n        }\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(\n        defs.map(function(def, index) {\n          return parser.getDependency(type, index);\n        })\n      );\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          byteOffset % byteStride / elementBytes,\n          normalized\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices\n        );\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized\n          );\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      assignExtrasToUserData(texture, sourceDef);\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture)\n        return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (colorSpace !== void 0) {\n        if (typeof colorSpace === \"number\")\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n        if (\"colorSpace\" in texture)\n          texture.colorSpace = colorSpace;\n        else\n          texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(\n        Promise.all(\n          this._invokeAll(function(ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n          })\n        )\n      );\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor;\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace\n      );\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions)\n          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new Group();\n      if (meshDef.extensions)\n        addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6\n      );\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const parser = this;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0)\n        continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        if (node.updateMatrix) {\n          node.updateMatrix();\n        }\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k]);\n          }\n        }\n      }\n      return new AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh)\n            return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(\n        parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        })\n      );\n    }\n    parser._invokeAll(function(ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = [];\n    const targetName = node.name ? node.name : node.uuid;\n    const targetNames = [];\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function(object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      });\n    } else {\n      targetNames.push(targetName);\n    }\n    let TypedKeyframeTrack;\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack;\n        break;\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n        break;\n    }\n    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n    const outputArray = this._getArrayFromAccessor(outputAccessor);\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation\n      );\n      if (sampler.interpolation === \"CUBICSPLINE\") {\n        this._createCubicSplineTrackInterpolant(track);\n      }\n      tracks.push(track);\n    }\n    return tracks;\n  }\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array;\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor);\n      const scaled = new Float32Array(outputArray.length);\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale;\n      }\n      outputArray = scaled;\n    }\n    return outputArray;\n  }\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n    };\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\nexport {\n  GLTFLoader\n};\n//# sourceMappingURL=GLTFLoader.js.map\n","const HorizontalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1 / 512 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n  )\n};\nexport {\n  HorizontalBlurShader\n};\n//# sourceMappingURL=HorizontalBlurShader.js.map\n","const VerticalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    v: { value: 1 / 512 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `\n  )\n};\nexport {\n  VerticalBlurShader\n};\n//# sourceMappingURL=VerticalBlurShader.js.map\n","import { DataTextureLoader, HalfFloatType, FloatType, DataUtils, LinearFilter } from \"three\";\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse(buffer) {\n    const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n        case rgbe_write_error:\n          throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n        case rgbe_format_error:\n          throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n        default:\n        case rgbe_memory_error:\n          throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n      }\n    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n      const chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n      }\n      if (-1 < i) {\n        if (false !== consume)\n          buffer2.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n      return false;\n    }, RGBE_ReadHeader = function(buffer2) {\n      const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n        valid: 0,\n        string: \"\",\n        comments: \"\",\n        programtype: \"RGBE\",\n        format: \"\",\n        gamma: 1,\n        exposure: 1,\n        width: 0,\n        height: 0\n      };\n      let line, match;\n      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n        rgbe_error(rgbe_read_error, \"no header found\");\n      }\n      if (!(match = line.match(magic_token_re))) {\n        rgbe_error(rgbe_format_error, \"bad initial token\");\n      }\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + \"\\n\";\n      while (true) {\n        line = fgets(buffer2);\n        if (false === line)\n          break;\n        header.string += line + \"\\n\";\n        if (\"#\" === line.charAt(0)) {\n          header.comments += line + \"\\n\";\n          continue;\n        }\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1]);\n        }\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1]);\n        }\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1];\n        }\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)\n          break;\n      }\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        rgbe_error(rgbe_format_error, \"missing format specifier\");\n      }\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        rgbe_error(rgbe_format_error, \"missing image size specifier\");\n      }\n      return header;\n    }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {\n      const scanline_width = w2;\n      if (\n        // run length encoding is not allowed so read flat\n        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n        2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128\n      ) {\n        return new Uint8Array(buffer2);\n      }\n      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n        rgbe_error(rgbe_format_error, \"wrong scanline width\");\n      }\n      const data_rgba = new Uint8Array(4 * w2 * h2);\n      if (!data_rgba.length) {\n        rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n      }\n      let offset = 0, pos = 0;\n      const ptr_end = 4 * scanline_width;\n      const rgbeStart = new Uint8Array(4);\n      const scanline_buffer = new Uint8Array(ptr_end);\n      let num_scanlines = h2;\n      while (num_scanlines > 0 && pos < buffer2.byteLength) {\n        if (pos + 4 > buffer2.byteLength) {\n          rgbe_error(rgbe_read_error);\n        }\n        rgbeStart[0] = buffer2[pos++];\n        rgbeStart[1] = buffer2[pos++];\n        rgbeStart[2] = buffer2[pos++];\n        rgbeStart[3] = buffer2[pos++];\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n        }\n        let ptr = 0, count;\n        while (ptr < ptr_end && pos < buffer2.byteLength) {\n          count = buffer2[pos++];\n          const isEncodedRun = count > 128;\n          if (isEncodedRun)\n            count -= 128;\n          if (0 === count || ptr + count > ptr_end) {\n            rgbe_error(rgbe_format_error, \"bad scanline data\");\n          }\n          if (isEncodedRun) {\n            const byteValue = buffer2[pos++];\n            for (let i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            }\n          } else {\n            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        }\n        const l = scanline_width;\n        for (let i = 0; i < l; i++) {\n          let off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n        num_scanlines--;\n      }\n      return data_rgba;\n    };\n    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2, e - 128) / 255;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n      destArray[destOffset + 3] = 1;\n    };\n    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2, e - 128) / 255;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);\n    };\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n    const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n    let data, type;\n    let numElements;\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4;\n        const floatArray = new Float32Array(numElements * 4);\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n        }\n        data = floatArray;\n        type = FloatType;\n        break;\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4;\n        const halfArray = new Uint16Array(numElements * 4);\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n        }\n        data = halfArray;\n        type = HalfFloatType;\n        break;\n      default:\n        throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n    }\n    return {\n      width: w,\n      height: h,\n      data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if (\"colorSpace\" in texture)\n            texture.colorSpace = \"srgb-linear\";\n          else\n            texture.encoding = 3e3;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  RGBELoader\n};\n//# sourceMappingURL=RGBELoader.js.map\n","import { Texture, DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, RedFormat, LinearFilter, DataUtils } from \"three\";\nimport { unzlibSync } from \"fflate\";\nconst hasColorSpace = \"colorSpace\" in new Texture();\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE)\n        lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = { l: 0, c: 0, lc: 0 };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i)\n        hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i)\n        hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0)\n          hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni)\n          return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = { c: 0, lc: 0 };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = { c: 0, lc: 0 };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = { a: 0, b: 0 };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n)\n        p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p01 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array2,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset\n                  );\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop)\n          break;\n        out[s++] = source[t1++];\n        if (s > stop)\n          break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = { value: 0 };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1)\n          maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1)\n            maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2)\n          continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount\n            );\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded)\n          continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function(dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\n        \"NO_COMPRESSION\",\n        \"RLE_COMPRESSION\",\n        \"ZIPS_COMPRESSION\",\n        \"ZIP_COMPRESSION\",\n        \"PIZ_COMPRESSION\",\n        \"PXR24_COMPRESSION\",\n        \"B44_COMPRESSION\",\n        \"B44A_COMPRESSION\",\n        \"DWAA_COMPRESSION\",\n        \"DWAB_COMPRESSION\"\n      ];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return { xMin, yMin, xMax, yMax };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if ((spec & ~4) != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++)\n        parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4)\n        EXRDecoder2.format = RGBAFormat;\n      else\n        EXRDecoder2.format = RedFormat;\n      if (hasColorSpace)\n        EXRDecoder2.colorSpace = \"srgb-linear\";\n      else\n        EXRDecoder2.encoding = 3e3;\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = { value: 0 };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = { value: 0 };\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height)\n          break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace)\n        texture.colorSpace = texData.colorSpace;\n      else\n        texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  EXRLoader\n};\n//# sourceMappingURL=EXRLoader.js.map\n","import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport {\n  DRACOLoader\n};\n//# sourceMappingURL=DRACOLoader.js.map\n","let generated;\nconst MeshoptDecoder = () => {\n  if (generated)\n    return generated;\n  const wasm_base = \"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\";\n  const wasm_simd = \"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\";\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11\n  ]);\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167\n  ]);\n  if (typeof WebAssembly !== \"object\") {\n    return {\n      supported: false\n    };\n  }\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n  }\n  let instance;\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance;\n    instance.exports.__wasm_call_ctors();\n  });\n  function unpack(data) {\n    const result = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i);\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n    }\n    let write = 0;\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n    }\n    return result.buffer.slice(0, write);\n  }\n  function decode(fun, target, count, size, source, filter) {\n    const sbrk = instance.exports.sbrk;\n    const count4 = count + 3 & ~3;\n    const tp = sbrk(count4 * size);\n    const sp = sbrk(source.length);\n    const heap = new Uint8Array(instance.exports.memory.buffer);\n    heap.set(source, sp);\n    const res = fun(tp, count, size, sp, source.length);\n    if (res === 0 && filter) {\n      filter(tp, count4, size);\n    }\n    target.set(heap.subarray(tp, tp + count * size));\n    sbrk(tp - sbrk(0));\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`);\n    }\n  }\n  const filters = {\n    // legacy index-based enums for glTF\n    0: \"\",\n    1: \"meshopt_decodeFilterOct\",\n    2: \"meshopt_decodeFilterQuat\",\n    3: \"meshopt_decodeFilterExp\",\n    // string-based enums for glTF\n    NONE: \"\",\n    OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n    QUATERNION: \"meshopt_decodeFilterQuat\",\n    EXPONENTIAL: \"meshopt_decodeFilterExp\"\n  };\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: \"meshopt_decodeVertexBuffer\",\n    1: \"meshopt_decodeIndexBuffer\",\n    2: \"meshopt_decodeIndexSequence\",\n    // string-based enums for glTF\n    ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n    TRIANGLES: \"meshopt_decodeIndexBuffer\",\n    INDICES: \"meshopt_decodeIndexSequence\"\n  };\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    }\n  };\n  return generated;\n};\nexport {\n  MeshoptDecoder\n};\n//# sourceMappingURL=MeshoptDecoder.js.map\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Clone } from './Clone.js';\nimport { GLTFLoader, DRACOLoader, MeshoptDecoder } from 'three-stdlib';\nimport { useLoader } from '@react-three/fiber';\n\nlet dracoLoader = null;\nlet decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';\nfunction extensions(useDraco, useMeshopt, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new DRACOLoader();\n      }\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);\n      loader.setDRACOLoader(dracoLoader);\n    }\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof MeshoptDecoder === 'function' ? MeshoptDecoder() : MeshoptDecoder);\n    }\n  };\n}\nfunction useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {\n  return useLoader(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n}\nuseGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\nuseGLTF.clear = input => useLoader.clear(GLTFLoader, input);\nuseGLTF.setDecoderPath = path => {\n  decoderPath = path;\n};\n\n//\n\nconst Gltf = /* @__PURE__ */React.forwardRef(({\n  src,\n  useDraco,\n  useMeshOpt,\n  extendLoader,\n  ...props\n}, ref) => {\n  const {\n    scene\n  } = useGLTF(src, useDraco, useMeshOpt, extendLoader);\n  return /*#__PURE__*/React.createElement(Clone, _extends({\n    ref: ref\n  }, props, {\n    object: scene\n  }));\n});\n\nexport { Gltf, useGLTF };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { OrbitControls as OrbitControls$1 } from 'three-stdlib';\n\nconst OrbitControls = /* @__PURE__ */React.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const setEvents = useThree(state => state.setEvents);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const performance = useThree(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = React.useMemo(() => new OrbitControls$1(explCamera), [explCamera]);\n  useFrame(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  React.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  React.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  React.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\nexport { OrbitControls };\n","/**\n * Sets `BufferAttribute.updateRange` since r159.\n */\nconst setUpdateRange = (attribute, updateRange) => {\n  if ('updateRanges' in attribute) {\n    // r159\n    // @ts-ignore\n    attribute.updateRanges[0] = updateRange;\n  } else {\n    attribute.updateRange = updateRange;\n  }\n};\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\n\n/**\n * TextureEncoding was deprecated in r152, and removed in r162.\n */\n\nexport { LinearEncoding, sRGBEncoding, setUpdateRange };\n","/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\nimport { RGBAFormat, LinearFilter, ClampToEdgeWrapping, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType, MeshBasicMaterial } from 'three';\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */\n        this.render = () => {\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            }\n            catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new Scene();\n        this._camera = new OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new Mesh(new PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @params options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, RGBAFormat, this._type, \n        // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, \n        // fixed value\n        LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\nexport { QuadRenderer as Q };\n","/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n        sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n        gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new QuadRenderer({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: HalfFloatType,\n        colorSpace: LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getAttribute = (description, name, defaultValue) => {\n    var _a;\n    let returnValue;\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!parsedValue) {\n        const node = description.getElementsByTagName(name)[0];\n        if (node) {\n            const values = node.getElementsByTagName('rdf:li');\n            if (values.length === 3) {\n                returnValue = Array.from(values).map(v => v.innerHTML);\n            }\n            else {\n                throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\n            }\n        }\n        else {\n            if (defaultValue)\n                return defaultValue;\n            else\n                throw new Error(`Can't find ${name} in gainmap metadata`);\n        }\n    }\n    else {\n        returnValue = parsedValue;\n    }\n    return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */\nconst extractXMP = (input) => {\n    var _a, _b;\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    const parser = new DOMParser();\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        str.slice(start, end + 10);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n            const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n            const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n            const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n            const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n            let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n            if (!hdrCapacityMin)\n                hdrCapacityMin = '0';\n            const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n            if (!hdrCapacityMax)\n                throw new Error('Incomplete gainmap metadata');\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops `));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\nclass LoaderBase extends Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */\n    constructor(renderer, manager) {\n        super(manager);\n        if (renderer)\n            this._renderer = renderer;\n        this._internalLoadingManager = new LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n    prepareQuadRenderer() {\n        if (!this._renderer)\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new Texture(),\n            sdr: new Texture()\n        });\n        return new QuadRenderer({\n            width: 16,\n            height: 16,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };\n","const presetsObj = {\n  apartment: 'lebombo_1k.hdr',\n  city: 'potsdamer_platz_1k.hdr',\n  dawn: 'kiara_1_dawn_1k.hdr',\n  forest: 'forest_slope_1k.hdr',\n  lobby: 'st_fagans_interior_1k.hdr',\n  night: 'dikhololo_night_1k.hdr',\n  park: 'rooitou_park_1k.hdr',\n  studio: 'studio_small_03_1k.hdr',\n  sunset: 'venice_sunset_1k.hdr',\n  warehouse: 'empty_warehouse_01_1k.hdr'\n};\n\nexport { presetsObj };\n","import { useThree, useLoader } from '@react-three/fiber';\nimport { CubeReflectionMapping, EquirectangularReflectionMapping, CubeTextureLoader } from 'three';\nimport { RGBELoader, EXRLoader } from 'three-stdlib';\nimport { HDRJPGLoader, GainMapLoader } from '@monogrid/gainmap-js';\nimport { presetsObj } from '../helpers/environment-assets.js';\nimport { sRGBEncoding, LinearEncoding } from '../helpers/deprecated.js';\nimport { useLayoutEffect } from 'react';\n\nconst CUBEMAP_ROOT = 'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/';\nconst isArray = arr => Array.isArray(arr);\nfunction useEnvironment({\n  files = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],\n  path = '',\n  preset = undefined,\n  encoding = undefined,\n  extensions\n} = {}) {\n  var _firstEntry$split$pop;\n  let loader = null;\n  let multiFile = false;\n  if (preset) {\n    if (!(preset in presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n  const isCubemap = isArray(files) && files.length === 6;\n  const isGainmap = isArray(files) && files.length === 3 && files.some(file => file.endsWith('json'));\n  const firstEntry = isArray(files) ? files[0] : files;\n\n  // Everything else\n  multiFile = isArray(files);\n  const extension = isCubemap ? 'cube' : isGainmap ? 'webp' : firstEntry.startsWith('data:application/exr') ? 'exr' : firstEntry.startsWith('data:application/hdr') ? 'hdr' : firstEntry.startsWith('data:image/jpeg') ? 'jpg' : (_firstEntry$split$pop = firstEntry.split('.').pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split('?')) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();\n  loader = extension === 'cube' ? CubeTextureLoader : extension === 'hdr' ? RGBELoader : extension === 'exr' ? EXRLoader : extension === 'jpg' || extension === 'jpeg' ? HDRJPGLoader : extension === 'webp' ? GainMapLoader : null;\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  const gl = useThree(state => state.gl);\n  useLayoutEffect(() => {\n    // Only required for gainmap\n    if (extension !== 'webp' && extension !== 'jpg' && extension !== 'jpeg') return;\n    function clearGainmapTexture() {\n      // @ts-expect-error\n      useLoader.clear(loader, multiFile ? [files] : files);\n    }\n    gl.domElement.addEventListener('webglcontextlost', clearGainmapTexture, {\n      once: true\n    });\n  }, [files, gl.domElement]);\n  const loaderResult = useLoader(\n  // @ts-expect-error\n  loader, multiFile ? [files] : files, loader => {\n    // Gainmap requires a renderer\n    if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n      loader.setRenderer(gl);\n    }\n    loader.setPath == null || loader.setPath(path);\n    if (extensions) extensions(loader);\n  });\n  let texture = multiFile ?\n  // @ts-ignore\n  loaderResult[0] : loaderResult;\n  if (extension === 'jpg' || extension === 'jpeg' || extension === 'webp') {\n    var _renderTarget;\n    texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;\n  }\n  texture.mapping = isCubemap ? CubeReflectionMapping : EquirectangularReflectionMapping;\n  if ('colorSpace' in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? 'srgb' : 'srgb-linear';else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? sRGBEncoding : LinearEncoding;\n  return texture;\n}\n\nexport { useEnvironment };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useThree, useFrame, createPortal, applyProps, extend } from '@react-three/fiber';\nimport { Scene, WebGLCubeRenderTarget, HalfFloatType } from 'three';\nimport { GroundProjectedEnv } from 'three-stdlib';\nimport { useEnvironment } from './useEnvironment.js';\n\nconst isRef = obj => obj.current && obj.current.isScene;\nconst resolveScene = scene => isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, sceneProps = {}) {\n  var _sceneProps$blur, _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;\n  // defaults\n  sceneProps = {\n    backgroundBlurriness: (_sceneProps$blur = sceneProps.blur) !== null && _sceneProps$blur !== void 0 ? _sceneProps$blur : 0,\n    backgroundIntensity: 1,\n    backgroundRotation: [0, 0, 0],\n    environmentIntensity: 1,\n    environmentRotation: [0, 0, 0],\n    ...sceneProps\n  };\n  const target = resolveScene(scene || defaultScene);\n  const oldbg = target.background;\n  const oldenv = target.environment;\n  const oldSceneProps = {\n    // @ts-ignore\n    backgroundBlurriness: target.backgroundBlurriness,\n    // @ts-ignore\n    backgroundIntensity: target.backgroundIntensity,\n    // @ts-ignore\n    backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [0, 0, 0],\n    // @ts-ignore\n    environmentIntensity: target.environmentIntensity,\n    // @ts-ignore\n    environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [0, 0, 0]\n  };\n  if (background !== 'only') target.environment = texture;\n  if (background) target.background = texture;\n  applyProps(target, sceneProps);\n  return () => {\n    if (background !== 'only') target.environment = oldenv;\n    if (background) target.background = oldbg;\n    applyProps(target, oldSceneProps);\n  };\n}\nfunction EnvironmentMap({\n  scene,\n  background = false,\n  map,\n  ...config\n}) {\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    if (map) return setEnvProps(background, scene, defaultScene, map, config);\n  });\n  return null;\n}\nfunction EnvironmentCube({\n  background = false,\n  scene,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  ...rest\n}) {\n  const texture = useEnvironment(rest);\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    return setEnvProps(background, scene, defaultScene, texture, {\n      blur,\n      backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  });\n  return null;\n}\nfunction EnvironmentPortal({\n  children,\n  near = 1,\n  far = 1000,\n  resolution = 256,\n  frames = 1,\n  map,\n  background = false,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  scene,\n  files,\n  path,\n  preset = undefined,\n  extensions\n}) {\n  const gl = useThree(state => state.gl);\n  const defaultScene = useThree(state => state.scene);\n  const camera = React.useRef(null);\n  const [virtualScene] = React.useState(() => new Scene());\n  const fbo = React.useMemo(() => {\n    const fbo = new WebGLCubeRenderTarget(resolution);\n    fbo.texture.type = HalfFloatType;\n    return fbo;\n  }, [resolution]);\n  React.useLayoutEffect(() => {\n    if (frames === 1) camera.current.update(gl, virtualScene);\n    return setEnvProps(background, scene, defaultScene, fbo.texture, {\n      blur,\n      backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);\n  let count = 1;\n  useFrame(() => {\n    if (frames === Infinity || count < frames) {\n      camera.current.update(gl, virtualScene);\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo]\n  }), files || preset ? /*#__PURE__*/React.createElement(EnvironmentCube, {\n    background: true,\n    files: files,\n    preset: preset,\n    path: path,\n    extensions: extensions\n  }) : map ? /*#__PURE__*/React.createElement(EnvironmentMap, {\n    background: true,\n    map: map,\n    extensions: extensions\n  }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n  var _props$ground, _props$ground2, _scale, _props$ground3;\n  const textureDefault = useEnvironment(props);\n  const texture = props.map || textureDefault;\n  React.useMemo(() => extend({\n    GroundProjectedEnvImpl: GroundProjectedEnv\n  }), []);\n  const args = React.useMemo(() => [texture], [texture]);\n  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n  const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(EnvironmentMap, _extends({}, props, {\n    map: texture\n  })), /*#__PURE__*/React.createElement(\"groundProjectedEnvImpl\", {\n    args: args,\n    scale: scale,\n    height: height,\n    radius: radius\n  }));\n}\nfunction Environment(props) {\n  return props.ground ? /*#__PURE__*/React.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/React.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/React.createElement(EnvironmentPortal, props) : /*#__PURE__*/React.createElement(EnvironmentCube, props);\n}\n\nexport { Environment, EnvironmentCube, EnvironmentMap, EnvironmentPortal };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { HorizontalBlurShader, VerticalBlurShader } from 'three-stdlib';\n\nconst ContactShadows = /* @__PURE__ */React.forwardRef(({\n  scale = 10,\n  frames = Infinity,\n  opacity = 1,\n  width = 1,\n  height = 1,\n  blur = 1,\n  near = 0,\n  far = 10,\n  resolution = 512,\n  smooth = true,\n  color = '#000000',\n  depthWrite = false,\n  renderOrder,\n  ...props\n}, fref) => {\n  const ref = React.useRef(null);\n  const scene = useThree(state => state.scene);\n  const gl = useThree(state => state.gl);\n  const shadowCamera = React.useRef(null);\n  width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n  height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = React.useMemo(() => {\n    const renderTarget = new THREE.WebGLRenderTarget(resolution, resolution);\n    const renderTargetBlur = new THREE.WebGLRenderTarget(resolution, resolution);\n    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n    const planeGeometry = new THREE.PlaneGeometry(width, height).rotateX(Math.PI / 2);\n    const blurPlane = new THREE.Mesh(planeGeometry);\n    const depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.depthTest = depthMaterial.depthWrite = false;\n    depthMaterial.onBeforeCompile = shader => {\n      shader.uniforms = {\n        ...shader.uniforms,\n        ucolor: {\n          value: new THREE.Color(color)\n        }\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`,\n      //\n      `uniform vec3 ucolor;\n           void main() {\n          `);\n      shader.fragmentShader = shader.fragmentShader.replace('vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n      // Colorize the shadow, multiply by the falloff so that the center can remain darker\n      'vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );');\n    };\n    const horizontalBlurMaterial = new THREE.ShaderMaterial(HorizontalBlurShader);\n    const verticalBlurMaterial = new THREE.ShaderMaterial(VerticalBlurShader);\n    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n    return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];\n  }, [resolution, width, height, scale, color]);\n  const blurShadows = blur => {\n    blurPlane.visible = true;\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTargetBlur);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTarget);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.visible = false;\n  };\n  let count = 0;\n  let initialBackground;\n  let initialOverrideMaterial;\n  useFrame(() => {\n    if (shadowCamera.current && (frames === Infinity || count < frames)) {\n      count++;\n      initialBackground = scene.background;\n      initialOverrideMaterial = scene.overrideMaterial;\n      ref.current.visible = false;\n      scene.background = null;\n      scene.overrideMaterial = depthMaterial;\n      gl.setRenderTarget(renderTarget);\n      gl.render(scene, shadowCamera.current);\n      blurShadows(blur);\n      if (smooth) blurShadows(blur * 0.4);\n      gl.setRenderTarget(null);\n      ref.current.visible = true;\n      scene.overrideMaterial = initialOverrideMaterial;\n      scene.background = initialBackground;\n    }\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    \"rotation-x\": Math.PI / 2\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: renderOrder,\n    geometry: planeGeometry,\n    scale: [1, -1, 1],\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    transparent: true,\n    map: renderTarget.texture,\n    opacity: opacity,\n    depthWrite: depthWrite\n  })), /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: shadowCamera,\n    args: [-width / 2, width / 2, height / 2, -height / 2, near, far]\n  }));\n});\n\nexport { ContactShadows };\n","import { Suspense, useRef } from 'react'\nimport { Canvas, useFrame } from '@react-three/fiber'\nimport { Html, Environment, useGLTF, ContactShadows, OrbitControls } from '@react-three/drei'\nimport { Group, MathUtils } from \"three\";\nimport styled from \"styled-components\";\nimport { DreiGLTF, MacbookMeshProps, MacbookProps } from \"./Macbook.types\";\n\nconst MacbookModel = ({meshPath = '/meshes/macbook/mac-draco.glb', children}: MacbookMeshProps) => {\n    const groupRef = useRef<Group>(null)\n    // Load model\n    const gltf = useGLTF(meshPath, true)\n    console.log(\"GLTF\", gltf)\n    let {nodes, materials} = (gltf as any) as DreiGLTF\n    // Make it float\n    useFrame((state) => {\n        const t = state.clock.getElapsedTime()\n        const group = groupRef.current\n        if (!group) return\n\n        group.rotation.x = MathUtils.lerp(group.rotation.x, Math.cos(t / 2) / 20 + 0.25, 0.1)\n        group.rotation.y = MathUtils.lerp(group.rotation.y, Math.sin(t / 4) / 20, 0.1)\n        group.rotation.z = MathUtils.lerp(group.rotation.z, Math.sin(t / 8) / 20, 0.1)\n        group.position.y = MathUtils.lerp(group.position.y, (-2 + Math.sin(t / 2)) / 2, 0.1)\n    })\n    // The jsx graph was auto-generated by: https://github.com/pmndrs/gltfjsx\n    return (\n        <group ref={groupRef} dispose={null}>\n            <group rotation-x={-0.425} position={[0, -0.04, 0.41]}>\n                <group position={[0, 2.96, -0.13]} rotation={[Math.PI / 2, 0, 0]}>\n                    <mesh material={materials.aluminium} geometry={nodes['Cube008'].geometry}/>\n                    <mesh material={materials['matte.001']} geometry={nodes['Cube008_1'].geometry}/>\n                    <mesh geometry={nodes['Cube008_2'].geometry}>\n                        <Html className=\"content\" rotation-x={-Math.PI / 2} position={[0, 0.05, -0.09]} transform\n                              occlude>\n                            <div className=\"wrapper\" onPointerDown={(e) => e.stopPropagation()}>\n                                {children}\n                            </div>\n                        </Html>\n                    </mesh>\n                </group>\n            </group>\n            <mesh material={materials.keys} geometry={nodes.keyboard.geometry} position={[1.79, 0, 3.45]}/>\n            <group position={[0, -0.1, 3.39]}>\n                <mesh material={materials.aluminium} geometry={nodes['Cube002'].geometry}/>\n                <mesh material={materials.trackpad} geometry={nodes['Cube002_1'].geometry}/>\n            </group>\n            <mesh material={materials.touchbar} geometry={nodes.touchbar.geometry} position={[0, -0.03, 1.2]}/>\n        </group>\n    )\n}\n\nconst MacbookContainer = styled.div`\n  width: 100%;\n  height: 100%;\n\n  .content {\n    margin-top: 27px;\n    width: 334px;\n    height: 216px;\n    border-radius: 3px;\n    overflow-y: auto;\n    padding: 0;\n  }\n\n  .wrapper {\n    padding: 10px;\n    width: 668px;\n    height: 432px;\n    transform: scale(0.5);\n    transform-origin: top left;\n  }\n`\n\nexport const Macbook = ({meshPath = '/meshes/macbook/mac-draco.glb', children}: MacbookProps) => {\n    return (\n        <MacbookContainer>\n            <Canvas camera={{position: [-5, 0, -15], fov: 55}}>\n                <pointLight position={[10, 10, 10]} intensity={1.5}/>\n                <Suspense fallback={null}>\n                    <group rotation={[0, Math.PI, 0]} position={[0, 1, 0]}>\n                        <MacbookModel meshPath={meshPath}>{children}</MacbookModel>\n                    </group>\n                    <Environment preset=\"city\"/>\n                </Suspense>\n                <ContactShadows position={[0, -4.5, 0]} scale={20} blur={2} far={4.5}/>\n                <OrbitControls enablePan={false} enableZoom={false} minPolarAngle={Math.PI / 2.2}\n                               maxPolarAngle={Math.PI / 2.2}/>\n            </Canvas>\n        </MacbookContainer>\n    )\n}"],"names":["v1","Vector3","v2","v3","v4","Vector2","defaultCalculatePosition","el","camera","size","objectPos","widthHalf","heightHalf","isObjectBehindCamera","cameraPos","deltaCamObj","camDir","isObjectVisible","raycaster","occlude","elPos","screenPos","intersects","intersectionDistance","objectScale","OrthographicCamera","PerspectiveCamera","vFOV","dist","objectZIndex","zIndexRange","A","B","epsilon","value","getCSSMatrix","matrix","multipliers","prepend","matrix3d","i","getCameraCSSMatrix","getObjectCSSMatrix","scaleMultipliers","factor","f","isRefObject","ref","Html","React.forwardRef","children","eps","style","className","center","fullscreen","portal","distanceFactor","sprite","transform","onOcclude","castShadow","receiveShadow","material","geometry","calculatePosition","as","wrapperClass","pointerEvents","props","gl","scene","events","viewport","useThree","React.useState","root","React.useRef","group","oldZoom","oldPosition","transformOuterRef","transformInnerRef","target","occlusionMeshRef","isMeshSizeSet","isRayCastOcclusion","React.useMemo","React.useLayoutEffect","currentRoot","ReactDOM.createRoot","vec","styles","transformInnerStyles","_root$current","React.createElement","_root$current2","visible","useFrame","isBehindCamera","raytraceTarget","item","previouslyVisible","isvisible","halfRange","zRange","fov","isOrthographicCamera","top","left","bottom","right","cameraMatrix","cameraTransform","scale","ratio","w","h","ele","shaders","_extends","DoubleSide","version","REVISION","toTrianglesDrawMode","drawMode","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","index","indices","position","numberOfTriangles","newIndices","newGeometry","u8","u16","u32","fleb","fdeb","clim","freb","eb","start","b","j","_a","fl","revfl","_b","fd","rev","x","hMap","cd","mb","r","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","shft","slc","e","n","inflt","dat","buf","st","sl","noBuf","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","t","lms","dms","lpos","sym","add","dsym","end","et","zlv","unzlibSync","data","out","td","tds","isCubeTexture","def","GroundProjectedEnv","Mesh","texture","options","isCubeMap","cubeSize","_lodMax","_cubeSize","width","height","defines","vertexShader","fragmentShader","uniforms","IcosahedronGeometry","ShaderMaterial","radius","__defProp","__defNormalProp","obj","key","__publicField","_ray","Ray","_plane","Plane","TILT_LIMIT","moduloWrapAround","offset","capacity","EventDispatcher","object","domElement","MOUSE","TOUCH","spherical","phi","currentPhi","phiDist","sphericalDelta","scope","theta","currentTheta","thetaDist","domElement2","onKeyDown","changeEvent","state","STATE","up","quat","Quaternion","quatInverse","lastPosition","lastQuaternion","twoPI","rotateLeft","getAutoRotationAngle","min","panOffset","performCursorZoom","clampDistance","zoomChanged","newRadius","prevRadius","radiusDelta","dollyDirection","mouseBefore","mouse","mouseAfter","EPS","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","_c","_d","_e","_f","onPointerMove","startEvent","endEvent","Spherical","rotateStart","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","angle","rotateUp","panLeft","distance","objectMatrix","panUp","pan","deltaX","deltaY","element","targetDistance","dollyOut","dollyScale","dollyIn","updateMouseParameters","event","rect","y","handleMouseDownRotate","handleMouseDownDolly","handleMouseDownPan","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","handleMouseWheel","handleKeyDown","needsUpdate","handleTouchStartRotate","handleTouchStartPan","handleTouchStartDolly","dx","dy","handleTouchStartDollyPan","handleTouchStartDollyRotate","handleTouchMoveRotate","getSecondPointerPosition","handleTouchMovePan","handleTouchMoveDolly","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","addPointer","onTouchStart","onMouseDown","onTouchMove","onMouseMove","removePointer","mouseAction","trackPointer","pointer","decodeText","array","il","SRGBColorSpace","LinearSRGBColorSpace","sRGBEncoding","LinearEncoding","GLTFLoader","Loader","manager","parser","GLTFMaterialsClearcoatExtension","GLTFMaterialsDispersionExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsBumpExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","url","onLoad","onProgress","onError","resourcePath","relativeUrl","LoaderUtils","_onError","loader","FileLoader","gltf","dracoLoader","ktx2Loader","meshoptDecoder","callback","path","json","extensions","plugins","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","GLTFBinaryExtension","error","GLTFParser","plugin","extensionName","extensionsRequired","GLTFMaterialsUnlitExtension","GLTFDracoMeshCompressionExtension","GLTFTextureTransformExtension","GLTFMeshQuantizationExtension","resolve","reject","GLTFRegistry","objects","nodeDefs","nodeIndex","nodeLength","nodeDef","lightIndex","cacheKey","dependency","lightDef","lightNode","color","Color","range","DirectionalLight","PointLight","SpotLight","assignExtrasToUserData","self2","light","MeshBasicMaterial","materialParams","materialDef","pending","metallicRoughness","materialIndex","emissiveStrength","MeshPhysicalMaterial","extension","colorFactor","colorArray","textureIndex","textureDef","name","source","handler","isSupported","image","bufferView","extensionDef","buffer","decoder","res","byteOffset","byteLength","count","stride","res2","result","meshDef","primitive","WEBGL_CONSTANTS","attributesDef","attributes","accessor","results","nodeObject","meshes","instancedMeshes","mesh","Matrix4","q","instancedMesh","InstancedMesh","attributeName","attr","InstancedBufferAttribute","Object3D","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","headerView","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","accessorDef","componentType","WEBGL_COMPONENT_TYPES","attribute","normalized","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","values","valueSize","i1","t0","t1","stride2","stride3","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","PATH_PROPERTIES","INTERPOLATION","InterpolateLinear","InterpolateDiscrete","ALPHA_MODES","createDefaultMaterial","cache","MeshStandardMaterial","FrontSide","addUnknownExtensionsToUserData","knownExtensions","objectDef","gltfDef","addMorphTargets","targets","hasMorphPosition","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","accessors","morphPositions","morphNormals","morphColors","updateMorphTargets","targetNames","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","attributesKey","keys","getNormalizedComponentScale","constructor","getImageURIMimeType","uri","_identityMatrix","isSafari","isFirefox","firefoxVersion","TextureLoader","ImageBitmapLoader","ext","dependencies","skinDefs","meshDefs","skinIndex","skinLength","joints","updateMappings","original","clone","mappings","child","func","defs","bufferIndex","bufferDef","bufferViewDef","accessorIndex","itemSize","TypedArray","BufferAttribute","pendingBufferViews","bufferViews","elementBytes","itemBytes","byteStride","bufferAttribute","ibSlice","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","sourceIndex","sourceDef","promise","sampler","URL","sourceURI","isObjectURL","blob","sourceURI2","imageBitmap","Texture","mapName","mapDef","colorSpace","gltfReference","useDerivativeTangents","useVertexColors","useFlatShading","pointsMaterial","PointsMaterial","Material","lineMaterial","LineBasicMaterial","cachedMaterial","materialType","materialExtensions","kmuExtension","alphaMode","emissiveFactor","originalName","sanitizedName","PropertyBinding","primitives","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","materials","geometries","SkinnedMesh","LineSegments","Line","LineLoop","Points","Group","cameraIndex","cameraDef","params","MathUtils","skinDef","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channel","input","output","nodes","inputAccessors","outputAccessors","samplers","tracks","node","inputAccessor","outputAccessor","createdTracks","k","AnimationClip","nodePending","childPending","childrenDef","skeletonPending","skeleton","nodeName","meshPromise","Bone","sceneIndex","sceneDef","nodeIds","reduceAssociations","reducedAssociations","node2","targetName","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","interpolation","outputArray","jl","track","scaled","interpolantType","computeBounds","box","Box3","boxScale","maxDisplacement","vector","sphere","Sphere","assignAttributeAccessor","gltfAttributeName","accessor2","HorizontalBlurShader","VerticalBlurShader","RGBELoader","DataTextureLoader","HalfFloatType","rgbe_error","rgbe_error_code","msg","NEWLINE","fgets","buffer2","lineLimit","consume","len","chunk","RGBE_ReadHeader","magic_token_re","gamma_re","exposure_re","format_re","dimensions_re","header","line","match","RGBE_ReadPixels_RLE","w2","h2","scanline_width","data_rgba","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","isEncodedRun","byteValue","off","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","RGBEByteToRGBHalf","DataUtils","byteArray","rgbe_header_info","image_rgba_data","numElements","FloatType","floatArray","halfArray","onLoadCallback","texData","hasColorSpace","EXRLoader","logBase","reverseLutFromBitmap","bitmap","lut","hufClearDecTable","hdec","getBitsReturn","getBits","nBits","lc","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","UInt16","Int16","wdec14Return","wdec14","ls","hs","hi","ai","bs","wdec16","bb","aa","wav2Decode","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","nData","predictor","interleaveScalar","t2","stop","decodeRunLength","reader","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","numComp","numFullBlocksX","numBlocksX","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp2","blocky","maxY","maxX","blockx","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset2","type2","y2","src","offset3","x2","halfRow","comp","decodeFloat16","acValue","dctComp","dst","g","alpha","beta","gamma","row","rowPtr","column","cb","cr","idx","toLinear","float","uncompressRAW","info","uncompressRLE","compressed","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","outBufferEnd","pizChannelData","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","length","tmpOffset2","cp","uncompressPXR","sz","tmpBufferEnd","writePtr","pixel","diff","uncompressDWA","dwaHeader","parseInt64","EXRHeader","channelRules","ruleSize","parseNullTerminatedString","compression","csc","channels","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","Uint32","Uint8","int","parseFloat32","decodeFloat32","binary","exponent","fraction","Uint16","parseFloat16","parseChlist","startOffset","pixelType","pLinear","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","parseHeader","EXRHeader2","spec","keepReading","attributeType","attributeSize","attributeValue","setupDecoder","outputType","EXRDecoder2","RGBAFormat","RedFormat","bufferDataView","uInt8Array","EXRDecoder","tmpOffset","channelOffsets","scanlineBlockIdx","viewer","line_y","true_y","channelID","cOff","outIndex","_taskCache","DRACOLoader","config","workerLimit","taskConfig","attributeIDs","attributeTypes","taskKey","cachedTask","worker","taskID","taskCost","geometryPending","_worker","message","geometryData","responseType","useJS","librariesPending","libraries","jsContent","fn","DRACOWorker","body","worker2","decoderConfig","decoderPending","draco","module","decoderBuffer","decodeGeometry","buffers","dracoGeometry","decodingStatus","geometryType","attributeID","decodeAttribute","decodeIndex","numIndices","numComponents","numValues","dataType","getDracoDataType","generated","MeshoptDecoder","wasm_base","wasm_simd","detector","wasmpack","wasm","instance","unpack","ch","write","decode","fun","filter","sbrk","count4","tp","sp","heap","filters","decoders","mode","decoderPath","useDraco","useMeshopt","extendLoader","useGLTF","useMeshOpt","useLoader","OrbitControls","makeDefault","regress","enableDamping","keyEvents","onChange","onStart","onEnd","restProps","invalidate","defaultCamera","setEvents","set","get","performance","explCamera","explDomElement","controls","OrbitControls$1","React.useEffect","onStartCb","onEndCb","old","getBufferForType","UnsignedByteType","UnsignedIntType","ByteType","ShortType","IntType","_canReadPixelsResult","canReadPixels","renderer","renderTargetOptions","testRT","WebGLRenderTarget","PlaneGeometry","QuadRenderer","_g","_h","_j","_k","_l","_m","_o","_p","_r","rtOptions","Scene","alternativeType","UVMapping","WebGLRenderer","returnValue","DataTexture","disposeRenderTarget","GainMapDecoderMaterial","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","NoBlending","val","GainMapNotFoundError","XMPMetadataNotFoundError","getAttribute","description","defaultValue","parsedValue","extractXMP","str","xmpBlock","offsetSDR","offsetHDR","MPFExtractor","imageArrayBuffer","debug","loops","marker","formatPt","tiffOffset","bigEnd","firstIFDOffset","dirStart","entriesStart","numberOfImages","nextIFDOffsetLen","MPImageListValPt","images","bufferBlob","imgs","imageBlob","extractGainmapFromJPEG","jpegFile","metadata","getHTMLImageFromBlob","img","LoaderBase","LoadingManager","quadRenderer","sdrBuffer","gainMapBuffer","gainMapBlob","sdrBlob","sdrImage","gainMapImage","needsFlip","LinearMipMapLinearFilter","GainMapLoader","sdrUrl","gainMapUrl","metadataUrl","loadCheck","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","total","loaded","lengthComputable","sdrLoader","gainMapLoader","metadataLoader","HDRJPGLoader","jpeg","jpegBuffer","sdrJPEG","gainMapJPEG","extractionResult","presetsObj","CUBEMAP_ROOT","isArray","arr","useEnvironment","files","preset","encoding","_firstEntry$split$pop","multiFile","isCubemap","isGainmap","file","firstEntry","CubeTextureLoader","useLayoutEffect","clearGainmapTexture","loaderResult","_renderTarget","CubeReflectionMapping","EquirectangularReflectionMapping","isRef","resolveScene","setEnvProps","background","defaultScene","sceneProps","_sceneProps$blur","_target$backgroundRot","_target$backgroundRot2","_target$environmentRo","_target$environmentRo2","oldbg","oldenv","oldSceneProps","applyProps","EnvironmentMap","map","EnvironmentCube","blur","backgroundBlurriness","backgroundIntensity","backgroundRotation","environmentIntensity","environmentRotation","rest","EnvironmentPortal","near","far","resolution","frames","virtualScene","fbo","WebGLCubeRenderTarget","React.Fragment","createPortal","EnvironmentGround","_props$ground","_props$ground2","_scale","_props$ground3","textureDefault","extend","args","Environment","ContactShadows","opacity","smooth","depthWrite","renderOrder","fref","shadowCamera","renderTarget","planeGeometry","depthMaterial","blurPlane","horizontalBlurMaterial","verticalBlurMaterial","renderTargetBlur","THREE.WebGLRenderTarget","THREE.PlaneGeometry","THREE.Mesh","THREE.MeshDepthMaterial","shader","THREE.Color","THREE.ShaderMaterial","blurShadows","initialBackground","initialOverrideMaterial","React.useImperativeHandle","MacbookModel","meshPath","groupRef","useRef","jsxs","jsx","MacbookContainer","styled","Macbook","Canvas","Suspense"],"mappings":"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CAAC,EAC9BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,CAAC,CAAC,EAC9BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,CAAC,CAAC,EAC9BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,CAAC,CAAC,EAC9BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,EAAI,EAAE,EAAIH,EAAcL,EAAI,EAAE,CAAC,EAC/BQ,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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]}